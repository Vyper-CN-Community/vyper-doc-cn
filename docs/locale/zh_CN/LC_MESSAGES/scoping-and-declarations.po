# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2024 CC-BY-4.0 Vyper Team
# This file is distributed under the same license as the Vyper package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Vyper \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-08 10:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../scoping-and-declarations.rst:4
msgid "Scoping and Declarations"
msgstr "作用域和声明"

#: ../../scoping-and-declarations.rst:7
msgid "Variable Declaration"
msgstr "变量声明"

#: ../../scoping-and-declarations.rst:9
msgid ""
"The first time a variable is referenced you must declare its :ref:`type "
"<types>`:"
msgstr "首次引用变量时，必须声明其 :ref:`类型 <types>` ："

#: ../../scoping-and-declarations.rst:15
msgid ""
"In the above example, we declare the variable ``data`` with a type of "
"``int128``."
msgstr "在上面的示例中，我们声明了类型为 ``int128`` 的变量 ``data``。"

#: ../../scoping-and-declarations.rst:17
msgid ""
"Depending on the active scope, an initial value may or may not be "
"assigned:"
msgstr "根据活动作用域，可以分配或不分配初始值："

#: ../../scoping-and-declarations.rst:19
msgid ""
"For storage variables (declared in the module scope), an initial value "
"**cannot** be set"
msgstr "对于存储变量（在模块作用域中声明），**不能**设置初始值"

#: ../../scoping-and-declarations.rst:20
msgid ""
"For memory variables (declared within a function), an initial value "
"**must** be set"
msgstr "对于内存变量（在函数中声明），**必须**设置初始值"

#: ../../scoping-and-declarations.rst:21
msgid ""
"For calldata variables (function input arguments), a default value "
"**may** be given"
msgstr "对于 calldata 变量（函数输入参数），**可以**给出默认值"

#: ../../scoping-and-declarations.rst:24
msgid "Declaring Public Variables"
msgstr "声明公共变量"

#: ../../scoping-and-declarations.rst:26
msgid "Storage variables can be marked as ``public`` during declaration:"
msgstr "存储变量可以在声明期间标记为 ``public`` ："

#: ../../scoping-and-declarations.rst:32
msgid ""
"The compiler automatically creates getter functions for all public "
"storage variables. For the example above, the compiler will generate a "
"function called ``data`` that does not take any arguments and returns an "
"``int128``, the value of the state variable data."
msgstr "编译器会自动为所有公共存储变量创建 getter 函数。对于上面的示例，编译器将生成一个名为 ``data`` 的函数，该函数不带任何参数并返回一个 ``int128``，即状态变量 data 的值。"

#: ../../scoping-and-declarations.rst:34
msgid ""
"For public arrays, you can only retrieve a single element via the "
"generated getter. This mechanism exists to avoid high gas costs when "
"returning an entire array. The getter will accept an argument to specify "
"which element to return, for example ``data(0)``."
msgstr "对于公共数组，您只能通过生成的 getter 检索单个元素。存在此机制是为了避免在返回整个数组时产生高昂的 gas 成本。getter 将接受一个参数来指定要返回哪个元素，例如 ``data(0)``。"

#: ../../scoping-and-declarations.rst:39
msgid "Declaring Immutable Variables"
msgstr "声明不可变变量"

#: ../../scoping-and-declarations.rst:41
msgid "Variables can be marked as ``immutable`` during declaration:"
msgstr "变量可以在声明期间标记为 ``immutable`` ："

#: ../../scoping-and-declarations.rst:51
msgid ""
"Variables declared as immutable are similar to constants, except they are"
" assigned a value in the constructor of the contract. Immutable values "
"must be assigned a value at construction and cannot be assigned a value "
"after construction."
msgstr "声明为不可变的变量类似于常量，只是它们在合约的构造函数中被赋值。不可变值必须在构造时赋值，并且在构造后不能赋值。"

#: ../../scoping-and-declarations.rst:53
msgid ""
"The contract creation code generated by the compiler will modify the "
"contract’s runtime code before it is returned by appending all values "
"assigned to immutables to the runtime code returned by the constructor. "
"This is important if you are comparing the runtime code generated by the "
"compiler with the one actually stored in the blockchain."
msgstr "编译器生成的合约创建代码将在返回之前修改合约的运行时代码，方法是将分配给不可变变量的所有值附加到构造函数返回的运行时代码中。如果您要将编译器生成的运行时代码与实际存储在区块链中的代码进行比较，这一点很重要。"

#: ../../scoping-and-declarations.rst:56
msgid "Tuple Assignment"
msgstr "元组赋值"

#: ../../scoping-and-declarations.rst:58
msgid ""
"You cannot directly declare tuple types. However, in certain cases you "
"can use literal tuples during assignment. For example, when a function "
"returns multiple values:"
msgstr "您不能直接声明元组类型。但是，在某些情况下，您可以在赋值期间使用字面量形式的元组（直接写出的元组）。例如，当函数返回多个值时："

#: ../../scoping-and-declarations.rst:79
msgid "Storage Layout"
msgstr "存储布局"

#: ../../scoping-and-declarations.rst:81
msgid ""
"Storage variables are located within a smart contract at specific storage"
" slots. By default, the compiler allocates the first variable to be "
"stored at ``slot 0``; subsequent variables are stored in order after "
"that."
msgstr "存储变量位于智能合约中的特定存储槽中。默认情况下，编译器将第一个变量分配到 ``slot 0`` 进行存储；后续变量按顺序存储在该变量之后。"

#: ../../scoping-and-declarations.rst:83
msgid ""
"There are cases where it is necessary to override this pattern and to "
"allocate storage variables in custom slots. This behaviour is often "
"required for upgradeable contracts, to ensure that both contracts (the "
"old contract, and the new contract) store the same variable within the "
"same slot."
msgstr "在某些情况下，有必要覆盖此模式并在自定义槽中分配存储变量。对于可升级合约，通常需要此行为，以确保两个合约（旧合约和新合约）将相同的变量存储在同一个槽中。"

#: ../../scoping-and-declarations.rst:85
msgid ""
"This can be performed when compiling  via ``vyper`` by including the "
"``--storage-layout-file`` flag."
msgstr "这可以在通过 ``vyper`` 编译时通过包含 ``--storage-layout-file`` 标志来执行。"

#: ../../scoping-and-declarations.rst:87
msgid "For example, consider upgrading the following contract:"
msgstr "例如，考虑升级以下合约："

#: ../../scoping-and-declarations.rst:102
msgid ""
"This would cause an issue when upgrading, as the ``balanceOf`` mapping "
"would be located at ``slot1`` in the old contract, and ``slot2`` in the "
"new contract."
msgstr "这会在升级时导致问题，因为 ``balanceOf`` 映射在旧合约中位于 ``slot1``，而在新合约中位于 ``slot2``。"

#: ../../scoping-and-declarations.rst:104
msgid ""
"This issue can be avoided by allocating ``balanceOf`` to ``slot1`` using "
"the storage layout overrides. The contract can be compiled with ``vyper "
"new_contract.vy --storage-layout-file new_contract_storage.json`` where "
"``new_contract_storage.json`` contains the following:"
msgstr "可以通过使用存储布局覆盖将 ``balanceOf`` 分配给 ``slot1`` 来避免此问题。可以使用 ``vyper new_contract.vy --storage-layout-file new_contract_storage.json`` 编译合约，其中 ``new_contract_storage.json`` 包含以下内容："

#: ../../scoping-and-declarations.rst:114
msgid ""
"When creating a custom storage layout, you must also include ``n_slots`` "
"for each storage variable. This tells the compiler how many 32 byte slots"
" to allocate from the ``slot`` storage offset."
msgstr "创建自定义存储布局时，还必须为每个存储变量包含 ``n_slots``。这会告诉编译器从 ``slot`` 存储偏移量分配多少个 32 字节的槽。"

#: ../../scoping-and-declarations.rst:116
msgid ""
"For further information on generating the storage layout, see "
":ref:`Storage Layout <compiler-storage-layout>`."
msgstr "有关生成存储布局的更多信息，请参阅 :ref:`存储布局 <compiler-storage-layout>`。"

#: ../../scoping-and-declarations.rst:119
msgid "Scoping Rules"
msgstr "作用域规则"

#: ../../scoping-and-declarations.rst:121
msgid ""
"Vyper follows C99 scoping rules. Variables are visible from the point "
"right after their declaration until the end of the smallest block that "
"contains the declaration."
msgstr "Vyper 遵循 C99 作用域规则。变量从其声明之后的位置开始可见，直到包含该声明的最小块的末尾。"

#: ../../scoping-and-declarations.rst:126
msgid "Module Scope"
msgstr "模块作用域"

#: ../../scoping-and-declarations.rst:128
msgid ""
"Variables and other items declared outside of a code block (functions, "
"constants, event and struct definitions, ...), are visible even before "
"they were declared. This means you can use module-scoped items before "
"they are declared."
msgstr "在代码块（函数、常量、事件和结构定义等）之外声明的变量和其他项，即使在声明之前也是可见的。这意味着您可以在声明之前使用模块作用域的项。"

#: ../../scoping-and-declarations.rst:131
msgid "Accessing Module Scope from Functions"
msgstr "从函数访问模块作用域"

#: ../../scoping-and-declarations.rst:133
msgid ""
"Values that are declared in the module scope of a contract, such as "
"storage variables and functions, are accessed via the ``self`` object:"
msgstr "在合约的模块作用域中声明的值（例如存储变量和函数）通过 ``self`` 对象访问："

#: ../../scoping-and-declarations.rst:149
msgid "Name Shadowing"
msgstr "名称遮蔽"

#: ../../scoping-and-declarations.rst:151
msgid ""
"It is not permitted for a memory or calldata variable to shadow the name "
"of an immutable or constant value. The following examples will not "
"compile:"
msgstr "不允许内存或 calldata 变量遮蔽不可变或常量值的名称。以下示例将无法编译："

#: ../../scoping-and-declarations.rst:176
msgid "Function Scope"
msgstr "函数作用域"

#: ../../scoping-and-declarations.rst:178
msgid ""
"Variables that are declared within a function, or given as function input"
" arguments, are visible within the body of that function. For example, "
"the following contract is valid because each declaration of ``a`` only "
"exists within one function's body."
msgstr "在函数中声明或作为函数输入参数给出的变量在该函数的主体内可见。例如，以下合约是有效的，因为 ``a`` 的每个声明仅存在于一个函数的主体内。"

#: ../../scoping-and-declarations.rst:194
msgid "The following examples will not compile:"
msgstr "以下示例将无法编译："

#: ../../scoping-and-declarations.rst:217
msgid "Block Scopes"
msgstr "块作用域"

#: ../../scoping-and-declarations.rst:219
msgid ""
"Logical blocks created by ``for`` and ``if`` statements have their own "
"scope. For example, the following contract is valid because ``x`` only "
"exists within the block scopes for each branch of the ``if`` statement:"
msgstr "由 ``for`` 和 ``if`` 语句创建的逻辑块有自己的作用域。例如，以下合约是有效的，因为 ``x`` 仅存在于 ``if`` 语句的每个分支的块作用域内："

#: ../../scoping-and-declarations.rst:230
msgid ""
"In a ``for`` statement, the target variable exists within the scope of "
"the loop. For example, the following contract is valid because ``i`` is "
"no longer available upon exiting the loop:"
msgstr "在 ``for`` 语句中，目标变量存在于循环的作用域内。例如，以下合约是有效的，因为退出循环后 ``i`` 不再可用："

#: ../../scoping-and-declarations.rst:240
msgid ""
"The following contract fails to compile because ``a`` has not been "
"declared outside of the loop."
msgstr "以下合约无法编译，因为 ``a`` 尚未在循环外声明。"