# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2024 CC-BY-4.0 Vyper Team
# This file is distributed under the same license as the Vyper package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Vyper \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-08 10:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../interfaces.rst:4
msgid "Interfaces"
msgstr ""

#: ../../interfaces.rst:6
msgid ""
"An interface is a set of function definitions used to enable "
"communication between smart contracts. A contract interface defines all "
"of that contract's externally available functions. By importing the "
"interface, your contract now knows how to call these functions in other "
"contracts."
msgstr ""

#: ../../interfaces.rst:9
msgid "Declaring and using Interfaces"
msgstr ""

#: ../../interfaces.rst:11
msgid ""
"Interfaces can be added to contracts either through inline definition, or"
" by importing them from a separate file."
msgstr ""

#: ../../interfaces.rst:13
msgid "The ``interface`` keyword is used to define an inline external interface:"
msgstr ""

#: ../../interfaces.rst:21
msgid ""
"The defined interface can then be used to make external calls, given a "
"contract address:"
msgstr ""

#: ../../interfaces.rst:33
msgid ""
"The interface name can also be used as a type annotation for storage "
"variables. You then assign an address value to the variable to access "
"that interface. Note that casting an address to an interface is possible,"
" e.g. ``FooBar(<address_var>)``:"
msgstr ""

#: ../../interfaces.rst:47
msgid ""
"Specifying ``payable`` or ``nonpayable`` annotation in the interface "
"indicates that the call made to the external contract will be able to "
"alter storage, whereas ``view`` and ``pure`` calls will use a "
"``STATICCALL`` ensuring no storage can be altered during execution. "
"Additionally, ``payable`` allows non-zero value to be sent along with the"
" call."
msgstr ""

#: ../../interfaces.rst:49
msgid ""
"Either the ``extcall`` or ``staticcall`` keyword is required to precede "
"the external call to distinguish it from internal calls. The keyword must"
" match the visibility of the function, ``staticcall`` for ``pure`` and "
"``view`` functions, and ``extcall`` for ``payable`` and ``nonpayable`` "
"functions. Additionally, the output of a ``staticcall`` must be assigned "
"to a result."
msgstr ""

#: ../../interfaces.rst:53
msgid ""
"If the signature in an interface does not match the actual signature of "
"the called contract, you can get runtime errors or undefined behavior. "
"For instance, if you accidentally mark a ``nonpayable`` function as "
"``view``, calling that function may result in the EVM reverting execution"
" in the called contract."
msgstr ""

#: ../../interfaces.rst:70
msgid ""
"Vyper offers the option to set the following additional keyword arguments"
" when making external calls:"
msgstr ""

#: ../../interfaces.rst:73
msgid "Keyword"
msgstr ""

#: ../../interfaces.rst:73
msgid "Description"
msgstr ""

#: ../../interfaces.rst:75
msgid "``gas``"
msgstr ""

#: ../../interfaces.rst:75
msgid "Specify gas value for the call"
msgstr ""

#: ../../interfaces.rst:76
msgid "``value``"
msgstr ""

#: ../../interfaces.rst:76
msgid "Specify amount of ether sent with the call"
msgstr ""

#: ../../interfaces.rst:77
msgid "``skip_contract_check``"
msgstr ""

#: ../../interfaces.rst:77
msgid "Drop ``EXTCODESIZE`` check (but keep ``RETURNDATASIZE`` check)"
msgstr ""

#: ../../interfaces.rst:78
msgid "``default_return_value``"
msgstr ""

#: ../../interfaces.rst:78
msgid "Specify a default return value if no value is returned"
msgstr ""

#: ../../interfaces.rst:81
msgid ""
"The ``default_return_value`` parameter can be used to handle ERC20 tokens"
" affected by the missing return value bug in a way similar to "
"OpenZeppelin's ``safeTransfer`` for Solidity:"
msgstr ""

#: ../../interfaces.rst:89
msgid "Built-in Interfaces"
msgstr ""

#: ../../interfaces.rst:91
msgid ""
"Vyper includes common built-in interfaces such as `IERC20 "
"<https://eips.ethereum.org/EIPS/eip-20>`_ and `IERC721 "
"<https://eips.ethereum.org/EIPS/eip-721>`_. These are imported from "
"``ethereum.ercs``:"
msgstr ""

#: ../../interfaces.rst:99
msgid ""
"You can see all the available built-in interfaces in the `Vyper GitHub "
"<https://github.com/vyperlang/vyper/tree/master/vyper/builtins/interfaces>`_"
" repo."
msgstr ""

#: ../../interfaces.rst:102
msgid "Implementing an Interface"
msgstr ""

#: ../../interfaces.rst:104
msgid ""
"You can define an interface for your contract with the ``implements`` "
"statement:"
msgstr ""

#: ../../interfaces.rst:113
msgid ""
"This imports the defined interface from the vyper file at "
"``an_interface.vyi`` (or ``an_interface.json`` if using ABI json "
"interface type) and ensures your current contract implements all the "
"necessary external functions. If any interface functions are not included"
" in the contract, it will fail to compile. This is especially useful when"
" developing contracts around well-defined standards such as ERC20."
msgstr ""

#: ../../interfaces.rst:117
msgid ""
"Interfaces that implement functions with return values that require an "
"upper bound (e.g. ``Bytes``, ``DynArray``, or ``String``), the upper "
"bound defined in the interface represents the lower bound of the "
"implementation. Assuming a function ``my_func`` returns a value "
"``String[1]`` in the interface, this would mean for the implementation "
"function of ``my_func`` that the return value must have **at least** "
"length 1. This behavior might change in the future."
msgstr ""

#: ../../interfaces.rst:121
msgid ""
"Prior to v0.4.0, ``implements`` required that events defined in an "
"interface were re-defined in the \"implementing\" contract. As of v0.4.0,"
" this is no longer required because events can be used just by importing "
"them. Any events used in a contract will automatically be exported in the"
" ABI output."
msgstr ""

#: ../../interfaces.rst:125
msgid ""
"An interface function with default parameters (e.g. ``deposit(assets: "
"uint256, receiver: address = msg.sender)``) implies that the contract "
"being interfaced with supports these default arguments via the ABI-"
"encoded function signatures (e.g. "
"``keccak256(\"deposit(uint256,address)\")[:4]`` and "
"``keccak256(\"deposit(uint256)\")[:4]``). It is the responsibility of the"
" callee to implement the behavior associated with these defaults."
msgstr ""

#: ../../interfaces.rst:128
msgid "Standalone Interfaces"
msgstr ""

#: ../../interfaces.rst:130
msgid ""
"Standalone interfaces are written using a variant of standard Vyper "
"syntax. The body of each function must be an ellipsis (``...``). "
"Interface files must have a ``.vyi`` suffix in order to be found by an "
"import statement."
msgstr ""

#: ../../interfaces.rst:144
msgid "Extracting Interfaces"
msgstr ""

#: ../../interfaces.rst:146
msgid ""
"Vyper has a built-in format option to allow you to easily export a Vyper "
"interface from a pre-existing contract."
msgstr ""

#: ../../interfaces.rst:161
msgid ""
"If you want to export it as an inline interface, Vyper provides a utility"
" to extract that as well."
msgstr ""

#: ../../interfaces.rst:175
msgid ""
"The output can then easily be copy-pasted directly in a regular vyper "
"file."
msgstr ""

