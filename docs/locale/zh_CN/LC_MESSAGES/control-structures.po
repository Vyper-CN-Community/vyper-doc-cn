# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2024 CC-BY-4.0 Vyper Team
# This file is distributed under the same license as the Vyper package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Vyper \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-08 10:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../control-structures.rst:4
msgid "Control Structures"
msgstr ""

#: ../../control-structures.rst:9
msgid "Functions"
msgstr ""

#: ../../control-structures.rst:11
msgid ""
"Functions are executable units of code within a contract. Functions may "
"only be declared within a contract's :ref:`module scope <scoping-"
"module>`."
msgstr ""

#: ../../control-structures.rst:19
msgid ""
"Functions may be called internally or externally depending on their "
":ref:`visibility <function-visibility>`. Functions may accept input "
"arguments and return variables in order to pass values between them."
msgstr ""

#: ../../control-structures.rst:22
msgid "Visibility"
msgstr ""

#: ../../control-structures.rst:26
msgid ""
"You can optionally declare a function's visibility by using a "
":ref:`decorator <function-decorators>`. There are three visibility levels"
" in Vyper:"
msgstr ""

#: ../../control-structures.rst:28
msgid ""
"``@external``: exposed in the selector table, can be called by an "
"external call into this contract"
msgstr ""

#: ../../control-structures.rst:29
msgid ""
"``@internal`` (default): can be invoked only from within this contract. "
"Not available to external callers"
msgstr ""

#: ../../control-structures.rst:30
msgid ""
"``@deploy``: constructor code. This is code which is invoked once in the "
"lifetime of a contract, upon its deploy. It is not available at runtime "
"to either external callers or internal call invocations. At this time, "
"only the :ref:`__init__() function <init-function>` may be marked as "
"``@deploy``."
msgstr ""

#: ../../control-structures.rst:34
msgid "External Functions"
msgstr ""

#: ../../control-structures.rst:36
msgid ""
"External functions (marked with the ``@external`` decorator) are a part "
"of the contract interface and may only be called via transactions or from"
" other contracts."
msgstr ""

#: ../../control-structures.rst:48
msgid ""
"A Vyper contract cannot call directly between two external functions. If "
"you must do this, you can use an :ref:`interface <interfaces>`."
msgstr ""

#: ../../control-structures.rst:50
msgid ""
"External functions can use the ``@raw_return`` decorator to return raw "
"bytes without ABI-encoding:"
msgstr ""

#: ../../control-structures.rst:68
msgid ""
"For external functions with default arguments like ``def my_function(x: "
"uint256, b: uint256 = 1)`` the Vyper compiler will generate ``N+1`` "
"overloaded function selectors based on ``N`` default arguments. "
"Consequently, the ABI signature for a function (this includes interface "
"functions) excludes optional arguments when their default values are used"
" in the function call."
msgstr ""

#: ../../control-structures.rst:82
msgid "Internal Functions"
msgstr ""

#: ../../control-structures.rst:84
msgid ""
"Internal functions (optionally marked with the ``@internal`` decorator) "
"are only accessible from other functions within the same contract. They "
"are invoked via the :ref:`self<constants-self>` object:"
msgstr ""

#: ../../control-structures.rst:95
msgid ""
"Or for internal functions which are defined in :ref:`imported modules "
"<modules>`, they are invoked by prefixing the name of the module to the "
"function name:"
msgstr ""

#: ../../control-structures.rst:104
msgid ""
"Marking an internal function as ``payable`` specifies that the function "
"can interact with ``msg.value``. A ``nonpayable`` internal function can "
"be called from an external ``payable`` function, but it cannot access "
"``msg.value``."
msgstr ""

#: ../../control-structures.rst:113
msgid ""
"As of v0.4.0, the ``@internal`` decorator is optional. That is, functions"
" with no visibility decorator default to being ``internal``."
msgstr ""

#: ../../control-structures.rst:116
msgid ""
"Please note that for ``internal`` functions which use more than one "
"default parameter, Vyper versions ``>=0.3.8`` are recommended due to the "
"security advisory `GHSA-ph9x-4vc9-m39g "
"<https://github.com/vyperlang/vyper/security/advisories/GHSA-ph9x-"
"4vc9-m39g>`_."
msgstr ""

#: ../../control-structures.rst:120
msgid "The ``__init__`` Function"
msgstr ""

#: ../../control-structures.rst:124
msgid ""
"The ``__init__()`` function, also known as the constructor, is a special "
"initialization function that is only called at the time of deploying a "
"contract. It can be used to set initial values for storage or immutable "
"variables. It must be declared with the ``@deploy`` decorator. A common "
"use case is to set an ``owner`` variable with the creator of the "
"contract:"
msgstr ""

#: ../../control-structures.rst:134
msgid ""
"Additionally, :ref:`immutable variables <immutable-variables>` may only "
"be set within the constructor."
msgstr ""

#: ../../control-structures.rst:138
msgid "Mutability"
msgstr ""

#: ../../control-structures.rst:142
msgid ""
"You can optionally declare a function's mutability by using a "
":ref:`decorator <function-decorators>`. There are four mutability levels:"
msgstr ""

#: ../../control-structures.rst:144
msgid ""
"``@pure``: does not read from the contract state or any environment "
"variables."
msgstr ""

#: ../../control-structures.rst:145
msgid "``@view``: may read from the contract state, but does not alter it."
msgstr ""

#: ../../control-structures.rst:146
msgid ""
"``@nonpayable`` (default): may read from and write to the contract state,"
" but cannot receive Ether."
msgstr ""

#: ../../control-structures.rst:147
msgid ""
"``@payable``: may read from and write to the contract state, and can "
"receive and access Ether via ``msg.value``."
msgstr ""

#: ../../control-structures.rst:163
msgid "Functions default to ``nonpayable`` when no mutability decorator is used."
msgstr ""

#: ../../control-structures.rst:165
msgid ""
"Functions marked with ``@view`` cannot call mutable (``payable`` or "
"``nonpayable``) functions. Any external calls are made using the special "
"``STATICCALL`` opcode, which prevents state changes at the EVM level."
msgstr ""

#: ../../control-structures.rst:167
msgid "Functions marked with ``@pure`` cannot call non-``pure`` functions."
msgstr ""

#: ../../control-structures.rst:170
msgid ""
"The ``@nonpayable`` decorator is not strictly enforced on ``internal`` "
"functions when they are invoked through an ``external`` ``payable`` "
"function. As a result, an ``external`` ``payable`` function can invoke an"
" ``internal`` ``nonpayable`` function. However, the ``nonpayable`` "
"``internal`` function cannot have access to ``msg.value``."
msgstr ""

#: ../../control-structures.rst:173
msgid "Nonreentrancy Locks"
msgstr ""

#: ../../control-structures.rst:175
msgid ""
"The ``@nonreentrant`` decorator places a global nonreentrancy lock on a "
"function. An attempt by an external contract to call back into any other "
"``@nonreentrant`` function causes the transaction to revert."
msgstr ""

#: ../../control-structures.rst:185
msgid ""
"Nonreentrancy locks work by setting a specially allocated storage slot to"
" a ``<locked>`` value on function entrance, and setting it to an "
"``<unlocked>`` value on function exit. On function entrance, if the "
"storage slot is detected to be the ``<locked>`` value, execution reverts."
msgstr ""

#: ../../control-structures.rst:187
msgid ""
"You cannot put the ``@nonreentrant`` decorator on a ``pure`` function. "
"You can put it on a ``view`` function, but it only checks that the "
"function is not in a callback (the storage slot is not in the "
"``<locked>`` state), as ``view`` functions can only read the state, not "
"change it."
msgstr ""

#: ../../control-structures.rst:189
msgid ""
"You can put the ``@nonreentrant`` decorator on a ``__default__`` "
"function, but keep in mind that this will result in the contract "
"rejecting ETH payments from callbacks."
msgstr ""

#: ../../control-structures.rst:191
msgid ""
"You can view where the nonreentrant key is physically laid out in storage"
" by using ``vyper`` with the ``-f layout`` option (e.g., ``vyper -f "
"layout foo.vy``). Unless it is overridden, the compiler will allocate it "
"at slot ``0``."
msgstr ""

#: ../../control-structures.rst:194
msgid ""
"A mutable function can protect a ``view`` function from being called back"
" into (which is useful for instance, if a ``view`` function would return "
"inconsistent state during a mutable function), but a ``view`` function "
"cannot protect itself from being called back into. Note that mutable "
"functions can never be called from a ``view`` function because all "
"external calls out from a ``view`` function are protected by the use of "
"the ``STATICCALL`` opcode."
msgstr ""

#: ../../control-structures.rst:198
msgid ""
"A nonreentrant lock has an ``<unlocked>`` value of 3, and a ``<locked>`` "
"value of 2. Nonzero values are used to take advantage of net gas metering"
" - as of the Berlin hard fork, the net cost for utilizing a nonreentrant "
"lock is 2300 gas. Prior to v0.3.4, the ``<unlocked>`` and ``<locked>`` "
"values were 0 and 1, respectively."
msgstr ""

#: ../../control-structures.rst:201
msgid ""
"Prior to 0.4.0, nonreentrancy keys took a \"key\" argument for fine-"
"grained nonreentrancy control. As of 0.4.0, only a global nonreentrancy "
"lock is available."
msgstr ""

#: ../../control-structures.rst:204
msgid "The nonreentrant pragma"
msgstr ""

#: ../../control-structures.rst:206
msgid ""
"Beginning in 0.4.2, the ``#pragma nonreentrancy on`` pragma is available,"
" and it enables nonreentrancy on all external functions and public "
"getters (except for ``constants`` and ``immutables``) in the file. This "
"is to prepare for a future release, probably in the 0.5.x series, where "
"nonreentrant locks will be enabled by default language-wide."
msgstr ""

#: ../../control-structures.rst:208
msgid ""
"When the pragma is on, to re-enable reentrancy for a specific function, "
"add the ``@reentrant`` decorator. For getters, add the ``reentrant()`` "
"modifier. Here is an example:"
msgstr ""

#: ../../control-structures.rst:233
msgid ""
"The default is ``#pragma nonreentrancy off``, which can be used to signal"
" specifically that nonreentrancy protection is off in this file."
msgstr ""

#: ../../control-structures.rst:235
msgid ""
"Note that the same caveats about nonreentrancy on ``__default__()`` as "
"mentioned in the previous section apply here, since the ``__default__()``"
" function will be nonreentrant by default with the pragma on."
msgstr ""

#: ../../control-structures.rst:237
msgid ""
"With the pragma on, internal functions remain unlocked by default but can"
" still use the ``@nonreentrant`` decorator. External ``view`` functions "
"are protected by default (as before, checking the lock upon entry but "
"only reading its state). External ``pure`` functions do not interact with"
" the lock."
msgstr ""

#: ../../control-structures.rst:239
msgid ""
"Internal functions, ``__init__`` function and getters for ``constants`` "
"and ``immutables`` can be marked ``reentrant``. Reentrant behavior is the"
" default for these structures anyway, and this feature can be used to "
"explicitly highlight the fact."
msgstr ""

#: ../../control-structures.rst:242
msgid "All the protected functions share the same, global lock."
msgstr ""

#: ../../control-structures.rst:245
msgid ""
"Vyper disallows calling a ``nonreentrant`` function from another "
"``nonreentrant`` function, since the compiler implements nonreentrancy as"
" a global lock which is acquired at function entry."
msgstr ""

#: ../../control-structures.rst:248
msgid ""
"The ``nonreentrancy on/off`` pragma is scoped to the current file. If you"
" import a file without the ``nonreentrancy on`` pragma, the functions in "
"that file will behave as the author intended, that is, they will be "
"reentrant unless marked otherwise."
msgstr ""

#: ../../control-structures.rst:251
msgid ""
"The ``constant`` and ``immutable`` state variable getters don't check the"
" lock because the value of the variables can't change."
msgstr ""

#: ../../control-structures.rst:255
msgid "The ``__default__`` Function"
msgstr ""

#: ../../control-structures.rst:257
msgid ""
"A contract can also have a default function, which is executed on a call "
"to the contract if no other functions match the given function identifier"
" (or if none was supplied at all, such as through someone sending it "
"Eth). It is the same construct as fallback functions `in Solidity "
"<https://solidity.readthedocs.io/en/latest/contracts.html?highlight=fallback"
"#fallback-function>`_."
msgstr ""

#: ../../control-structures.rst:259
msgid ""
"This function is always named ``__default__``. It must be annotated with "
"``@external``. It cannot expect any input arguments."
msgstr ""

#: ../../control-structures.rst:261
msgid ""
"If the function is annotated as ``@payable``, this function is executed "
"whenever the contract is sent Ether (without data). This is why the "
"default function cannot accept arguments - it is a design decision of "
"Ethereum to make no differentiation between sending ether to a contract "
"or a user address."
msgstr ""

#: ../../control-structures.rst:275
msgid "Considerations"
msgstr ""

#: ../../control-structures.rst:277
msgid ""
"Just as in Solidity, Vyper generates a default function if one isn't "
"found, in the form of a ``REVERT`` call. Note that this rolls back state "
"changes, and thus will not succeed in receiving funds."
msgstr ""

#: ../../control-structures.rst:279
msgid ""
"Ethereum specifies that the operations will be rolled back if the "
"contract runs out of gas in execution. ``send`` calls to the contract "
"come with a free stipend of 2300 gas, which does not leave much room to "
"perform other operations except basic logging. **However**, if the sender"
" includes a higher gas amount through a ``call`` instead of ``send``, "
"then more complex functionality can be run."
msgstr ""

#: ../../control-structures.rst:281
msgid ""
"It is considered a best practice to ensure your payable default function "
"is compatible with this stipend. The following operations will consume "
"more than 2300 gas:"
msgstr ""

#: ../../control-structures.rst:283
msgid "Writing to storage"
msgstr ""

#: ../../control-structures.rst:284
msgid "Creating a contract"
msgstr ""

#: ../../control-structures.rst:285
msgid "Calling an external function which consumes a large amount of gas"
msgstr ""

#: ../../control-structures.rst:286
msgid "Sending Ether"
msgstr ""

#: ../../control-structures.rst:288
msgid ""
"Lastly, although the default function receives no arguments, it can still"
" access the ``msg`` object, including:"
msgstr ""

#: ../../control-structures.rst:290
msgid "the address of who is interacting with the contract (``msg.sender``)"
msgstr ""

#: ../../control-structures.rst:291
msgid "the amount of ETH sent (``msg.value``)"
msgstr ""

#: ../../control-structures.rst:292
msgid "the gas provided (``msg.gas``)."
msgstr ""

#: ../../control-structures.rst:297
msgid "Decorators Reference"
msgstr ""

#: ../../control-structures.rst:300
msgid "Decorator"
msgstr ""

#: ../../control-structures.rst:300
msgid "Description"
msgstr ""

#: ../../control-structures.rst:302
msgid "``@external``"
msgstr ""

#: ../../control-structures.rst:302
msgid ""
"Function can only be called externally, it is part of the runtime "
"selector table"
msgstr ""

#: ../../control-structures.rst:303
msgid "``@internal``"
msgstr ""

#: ../../control-structures.rst:303
msgid "Function can only be called within current contract"
msgstr ""

#: ../../control-structures.rst:304
msgid "``@deploy``"
msgstr ""

#: ../../control-structures.rst:304
msgid "Function is called only at deploy time"
msgstr ""

#: ../../control-structures.rst:305
msgid "``@pure``"
msgstr ""

#: ../../control-structures.rst:305
msgid "Function does not read contract state or environment variables"
msgstr ""

#: ../../control-structures.rst:306
msgid "``@view``"
msgstr ""

#: ../../control-structures.rst:306
msgid "Function does not alter contract state"
msgstr ""

#: ../../control-structures.rst:307
msgid "``@payable``"
msgstr ""

#: ../../control-structures.rst:307
msgid "Function is able to receive Ether"
msgstr ""

#: ../../control-structures.rst:308
msgid "``@nonreentrant``"
msgstr ""

#: ../../control-structures.rst:308
msgid "Function cannot be called back into during an external call"
msgstr ""

#: ../../control-structures.rst:309
msgid "``@raw_return``"
msgstr ""

#: ../../control-structures.rst:309
msgid ""
"Function returns raw bytes without ABI-encoding (``@external`` functions "
"only)"
msgstr ""

#: ../../control-structures.rst:313
msgid "Raw Return"
msgstr ""

#: ../../control-structures.rst:315
msgid ""
"The ``@raw_return`` decorator allows a function to return raw bytes "
"without ABI-encoding. This is particularly useful for proxy contracts and"
" other helper contracts where you want to forward the exact output bytes "
"from another contract call without adding an additional layer of ABI-"
"encoding."
msgstr ""

#: ../../control-structures.rst:326
msgid "The ``@raw_return`` decorator has the following restrictions:"
msgstr ""

#: ../../control-structures.rst:328
msgid "It can only be used on ``@external`` functions"
msgstr ""

#: ../../control-structures.rst:329
msgid "The function must have a ``Bytes[N]`` return type"
msgstr ""

#: ../../control-structures.rst:330
msgid ""
"It cannot be used on ``@deploy`` (constructor) functions (you can however"
" use it in the ``__default__()`` function)"
msgstr ""

#: ../../control-structures.rst:331
msgid "It cannot be used on ``@internal`` functions"
msgstr ""

#: ../../control-structures.rst:333
msgid ""
"When a function is marked with ``@raw_return``, the compiler directly "
"returns the bytes value using the EVM ``RETURN`` opcode, bypassing the "
"normal ABI-encoding that would wrap the bytes in a ``(bytes)`` tuple."
msgstr ""

#: ../../control-structures.rst:336
msgid ""
"The ``@raw_return`` decorator cannot be used in interface definitions "
"(``.vyi`` files). Note that to call a ``@raw_return`` function from "
"another contract, you should use ``raw_call`` instead of an interface "
"call, since the return data may not be ABI-encoded."
msgstr ""

#: ../../control-structures.rst:339
msgid ""
"When using ``@raw_return``, ensure all return paths in your function use "
"raw bytes. Having multiple return statements where some use ABI-encoded "
"data and others don't can lead to decoding errors."
msgstr ""

#: ../../control-structures.rst:342
msgid "``if`` statements"
msgstr ""

#: ../../control-structures.rst:344
msgid ""
"The ``if`` statement is a control flow construct used for conditional "
"execution:"
msgstr ""

#: ../../control-structures.rst:351
msgid ""
"``CONDITION`` is a boolean or boolean operation. The boolean is evaluated"
" left-to-right, one expression at a time, until the condition is found to"
" be true or false.  If true, the logic in the body of the ``if`` "
"statement is executed."
msgstr ""

#: ../../control-structures.rst:353
msgid ""
"Note that unlike Python, Vyper does not allow implicit conversion from "
"non-boolean types within the condition of an ``if`` statement. ``if 1: "
"pass`` will fail to compile with a type mismatch."
msgstr ""

#: ../../control-structures.rst:355
msgid ""
"You can also include ``elif`` and ``else`` statements, to add more "
"conditional statements and a body that executes when the conditionals are"
" false:"
msgstr ""

#: ../../control-structures.rst:367
msgid "``for`` loops"
msgstr ""

#: ../../control-structures.rst:369
msgid ""
"The ``for`` statement is a control flow construct used to iterate over a "
"value:"
msgstr ""

#: ../../control-structures.rst:376
msgid ""
"The iterated value can be a static array, a dynamic array, or generated "
"from the built-in ``range`` function."
msgstr ""

#: ../../control-structures.rst:379
msgid "Array Iteration"
msgstr ""

#: ../../control-structures.rst:381
msgid "You can use ``for`` to iterate through the values of any array variable:"
msgstr ""

#: ../../control-structures.rst:389
msgid ""
"In the above, example, the loop executes three times with ``i`` assigned "
"the values of ``4``, ``23``, and then ``42``."
msgstr ""

#: ../../control-structures.rst:391
msgid ""
"You can also iterate over a literal array, as long as the annotated type "
"is valid for each item in the array:"
msgstr ""

#: ../../control-structures.rst:398
msgid "Some restrictions:"
msgstr ""

#: ../../control-structures.rst:400
msgid ""
"You cannot iterate over a multi-dimensional array.  ``i`` must always be "
"a base type."
msgstr ""

#: ../../control-structures.rst:401
msgid ""
"You cannot modify a value in an array while it is being iterated, or call"
" to a function that might modify the array being iterated."
msgstr ""

#: ../../control-structures.rst:404
msgid "Range Iteration"
msgstr ""

#: ../../control-structures.rst:406
msgid ""
"Ranges are created using the ``range`` function. The following examples "
"are valid uses of ``range``:"
msgstr ""

#: ../../control-structures.rst:413
msgid ""
"``STOP`` is a literal integer greater than zero. ``i`` begins as zero and"
" increments by one until it is equal to ``STOP``. ``i`` must be of the "
"same type as ``STOP``."
msgstr ""

#: ../../control-structures.rst:420
msgid ""
"Here, ``stop`` can be a variable with integer type, greater than zero. "
"``N`` must be a compile-time constant. ``i`` begins as zero and "
"increments by one until it is equal to ``stop``. If ``stop`` is larger "
"than ``N``, execution will revert at runtime. In certain cases, you may "
"not have a guarantee that ``stop`` is less than ``N``, but still want to "
"avoid the possibility of runtime reversion. To accomplish this, use the "
"``bound=`` keyword in combination with ``min(stop, N)`` as the argument "
"to ``range``, like ``range(min(stop, N), bound=N)``. This is helpful for "
"use cases like chunking up operations on larger arrays across multiple "
"transactions. ``i``, ``stop`` and ``N`` must be of the same type."
msgstr ""

#: ../../control-structures.rst:422
msgid "Another use of range can be with ``START`` and ``STOP`` bounds."
msgstr ""

#: ../../control-structures.rst:429
msgid ""
"Here, ``START`` and ``STOP`` are literal integers, with ``STOP`` being a "
"greater value than ``START``. ``i`` begins as ``START`` and increments by"
" one until it is equal to ``STOP``. ``i``, ``START`` and ``STOP`` must be"
" of the same type."
msgstr ""

#: ../../control-structures.rst:431
msgid ""
"Finally, it is possible to use ``range`` with runtime `start` and `stop` "
"values as long as a constant `bound` value is provided. In this case, "
"Vyper checks at runtime that `end - start <= bound`. ``N`` must be a "
"compile-time constant. ``i``, ``stop`` and ``N`` must be of the same "
"type."
msgstr ""

