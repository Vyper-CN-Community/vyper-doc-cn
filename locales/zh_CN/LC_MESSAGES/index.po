# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2024 CC-BY-4.0 Vyper Team
# This file is distributed under the same license as the Vyper package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Vyper \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-08 10:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../index.rst:-1
msgid "Vyper logo"
msgstr ""

#: ../../index.rst:7
msgid "Vyper"
msgstr ""

#: ../../index.rst:9
msgid ""
"Vyper is a contract-oriented, Pythonic programming language that targets "
"the `Ethereum Virtual Machine (EVM) <https://ethereum.org/learn"
"/#ethereum-basics>`_. It prioritizes user safety, encourages clear coding"
" practices via language design and efficient execution. In other words, "
"Vyper code is safe, clear and efficient!"
msgstr ""

#: ../../index.rst:13
msgid "Principles and Goals"
msgstr ""

#: ../../index.rst:15
msgid ""
"**Security**: It should be possible and natural to build secure smart-"
"contracts in Vyper."
msgstr ""

#: ../../index.rst:16
msgid ""
"**Language and compiler simplicity**: The language and the compiler "
"implementation should strive to be simple."
msgstr ""

#: ../../index.rst:17
msgid ""
"**Auditability**: Vyper code should be maximally human-readable. "
"Furthermore, it should be maximally difficult to write misleading code. "
"Simplicity for the reader is more important than simplicity for the "
"writer, and simplicity for readers with low prior experience with Vyper "
"(and low prior experience with programming in general) is particularly "
"important."
msgstr ""

#: ../../index.rst:21
msgid "Because of this Vyper provides the following features:"
msgstr ""

#: ../../index.rst:23
msgid "**Bounds and overflow checking**: On array accesses and arithmetic."
msgstr ""

#: ../../index.rst:24
msgid "**Support for signed integers and decimal fixed point numbers**"
msgstr ""

#: ../../index.rst:25
msgid ""
"**Decidability**: It is possible to compute a precise upper bound for the"
" gas consumption of any Vyper function call."
msgstr ""

#: ../../index.rst:26
msgid "**Strong typing**"
msgstr ""

#: ../../index.rst:27
msgid "**Clean and understandable compiler code**"
msgstr ""

#: ../../index.rst:28
msgid ""
"**Support for pure functions**: Anything marked ``pure`` is not allowed "
"to change the state."
msgstr ""

#: ../../index.rst:29
msgid ""
"**Code reuse through composition**: Vyper supports code reuse through "
"composition, and requires syntactic marking of dependencies which "
"potentially modify state."
msgstr ""

#: ../../index.rst:31
msgid ""
"Following the principles and goals, Vyper **does not** provide the "
"following features:"
msgstr ""

#: ../../index.rst:33
#, python-brace-format
msgid ""
"**Modifiers**: For example in Solidity you can define a ``function foo() "
"mod1 { ... }``, where ``mod1`` can be defined elsewhere in the code to "
"include a check that is done before execution, a check that is done after"
" execution, some state changes, or possibly other things. Vyper does not "
"have this, because it makes it too easy to write misleading code. "
"``mod1`` just looks too innocuous for something that could add arbitrary "
"pre-conditions, post-conditions or state changes. Also, it encourages "
"people to write code where the execution jumps around the file, harming "
"auditability. The usual use case for a modifier is something that "
"performs a single check before execution of a program; our recommendation"
" is to simply inline these checks as asserts."
msgstr ""

#: ../../index.rst:34
msgid ""
"**Class inheritance**: Class inheritance requires readers to jump between"
" multiple files to understand what a program is doing, and requires "
"readers to understand the rules of precedence in case of conflicts "
"(\"Which class's function ``X`` is the one that's actually used?\")."
msgstr ""

#: ../../index.rst:35
msgid ""
"**Inline assembly**: Adding inline assembly would make it no longer "
"possible to search for a variable name in order to find all instances "
"where that variable is read or modified."
msgstr ""

#: ../../index.rst:36
msgid ""
"**Function overloading**: This can cause lots of confusion on which "
"function is called at any given time. Thus it's easier to write "
"misleading code (``foo(\"hello\")`` logs \"hello\" but ``foo(\"hello\", "
"\"world\")`` steals your funds). Another problem with function "
"overloading is that it makes the code much harder to search through as "
"you have to keep track on which call refers to which function."
msgstr ""

#: ../../index.rst:37
msgid ""
"**Operator overloading**: Operator overloading makes writing misleading "
"code possible. For example ``+`` could be overloaded so that it executes "
"commands that are not visible at a first glance, such as sending funds "
"the user did not want to send."
msgstr ""

#: ../../index.rst:38
msgid ""
"**Recursive calling**: Recursive calling makes it impossible to set an "
"upper bound on gas limits, opening the door for gas limit attacks."
msgstr ""

#: ../../index.rst:39
msgid ""
"**Infinite-length loops**: Similar to recursive calling, infinite-length "
"loops make it impossible to set an upper bound on gas limits, opening the"
" door for gas limit attacks."
msgstr ""

#: ../../index.rst:40
msgid ""
"**Binary fixed point**: Decimal fixed point is better, because any "
"decimal fixed point value written as a literal in code has an exact "
"representation, whereas with binary fixed point approximations are often "
"required (e.g. (0.2)\\ :sub:`10` = (0.001100110011...)\\ :sub:`2`, which "
"needs to be truncated), leading to unintuitive results, e.g. in Python "
"0.3 + 0.3 + 0.3 + 0.1 != 1."
msgstr ""

