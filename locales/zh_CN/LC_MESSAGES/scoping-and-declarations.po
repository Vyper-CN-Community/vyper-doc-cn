# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2024 CC-BY-4.0 Vyper Team
# This file is distributed under the same license as the Vyper package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Vyper \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-08 10:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../scoping-and-declarations.rst:4
msgid "Scoping and Declarations"
msgstr ""

#: ../../scoping-and-declarations.rst:7
msgid "Variable Declaration"
msgstr ""

#: ../../scoping-and-declarations.rst:9
msgid ""
"The first time a variable is referenced you must declare its :ref:`type "
"<types>`:"
msgstr ""

#: ../../scoping-and-declarations.rst:15
msgid ""
"In the above example, we declare the variable ``data`` with a type of "
"``int128``."
msgstr ""

#: ../../scoping-and-declarations.rst:17
msgid ""
"Depending on the active scope, an initial value may or may not be "
"assigned:"
msgstr ""

#: ../../scoping-and-declarations.rst:19
msgid ""
"For storage variables (declared in the module scope), an initial value "
"**cannot** be set"
msgstr ""

#: ../../scoping-and-declarations.rst:20
msgid ""
"For memory variables (declared within a function), an initial value "
"**must** be set"
msgstr ""

#: ../../scoping-and-declarations.rst:21
msgid ""
"For calldata variables (function input arguments), a default value "
"**may** be given"
msgstr ""

#: ../../scoping-and-declarations.rst:24
msgid "Declaring Public Variables"
msgstr ""

#: ../../scoping-and-declarations.rst:26
msgid "Storage variables can be marked as ``public`` during declaration:"
msgstr ""

#: ../../scoping-and-declarations.rst:32
msgid ""
"The compiler automatically creates getter functions for all public "
"storage variables. For the example above, the compiler will generate a "
"function called ``data`` that does not take any arguments and returns an "
"``int128``, the value of the state variable data."
msgstr ""

#: ../../scoping-and-declarations.rst:34
msgid ""
"For public arrays, you can only retrieve a single element via the "
"generated getter. This mechanism exists to avoid high gas costs when "
"returning an entire array. The getter will accept an argument to specify "
"which element to return, for example ``data(0)``."
msgstr ""

#: ../../scoping-and-declarations.rst:39
msgid "Declaring Immutable Variables"
msgstr ""

#: ../../scoping-and-declarations.rst:41
msgid "Variables can be marked as ``immutable`` during declaration:"
msgstr ""

#: ../../scoping-and-declarations.rst:51
msgid ""
"Variables declared as immutable are similar to constants, except they are"
" assigned a value in the constructor of the contract. Immutable values "
"must be assigned a value at construction and cannot be assigned a value "
"after construction."
msgstr ""

#: ../../scoping-and-declarations.rst:53
msgid ""
"The contract creation code generated by the compiler will modify the "
"contractâ€™s runtime code before it is returned by appending all values "
"assigned to immutables to the runtime code returned by the constructor. "
"This is important if you are comparing the runtime code generated by the "
"compiler with the one actually stored in the blockchain."
msgstr ""

#: ../../scoping-and-declarations.rst:56
msgid "Tuple Assignment"
msgstr ""

#: ../../scoping-and-declarations.rst:58
msgid ""
"You cannot directly declare tuple types. However, in certain cases you "
"can use literal tuples during assignment. For example, when a function "
"returns multiple values:"
msgstr ""

#: ../../scoping-and-declarations.rst:79
msgid "Storage Layout"
msgstr ""

#: ../../scoping-and-declarations.rst:81
msgid ""
"Storage variables are located within a smart contract at specific storage"
" slots. By default, the compiler allocates the first variable to be "
"stored at ``slot 0``; subsequent variables are stored in order after "
"that."
msgstr ""

#: ../../scoping-and-declarations.rst:83
msgid ""
"There are cases where it is necessary to override this pattern and to "
"allocate storage variables in custom slots. This behaviour is often "
"required for upgradeable contracts, to ensure that both contracts (the "
"old contract, and the new contract) store the same variable within the "
"same slot."
msgstr ""

#: ../../scoping-and-declarations.rst:85
msgid ""
"This can be performed when compiling  via ``vyper`` by including the "
"``--storage-layout-file`` flag."
msgstr ""

#: ../../scoping-and-declarations.rst:87
msgid "For example, consider upgrading the following contract:"
msgstr ""

#: ../../scoping-and-declarations.rst:102
msgid ""
"This would cause an issue when upgrading, as the ``balanceOf`` mapping "
"would be located at ``slot1`` in the old contract, and ``slot2`` in the "
"new contract."
msgstr ""

#: ../../scoping-and-declarations.rst:104
msgid ""
"This issue can be avoided by allocating ``balanceOf`` to ``slot1`` using "
"the storage layout overrides. The contract can be compiled with ``vyper "
"new_contract.vy --storage-layout-file new_contract_storage.json`` where "
"``new_contract_storage.json`` contains the following:"
msgstr ""

#: ../../scoping-and-declarations.rst:114
msgid ""
"When creating a custom storage layout, you must also include ``n_slots`` "
"for each storage variable. This tells the compiler how many 32 byte slots"
" to allocate from the ``slot`` storage offset."
msgstr ""

#: ../../scoping-and-declarations.rst:116
msgid ""
"For further information on generating the storage layout, see "
":ref:`Storage Layout <compiler-storage-layout>`."
msgstr ""

#: ../../scoping-and-declarations.rst:119
msgid "Scoping Rules"
msgstr ""

#: ../../scoping-and-declarations.rst:121
msgid ""
"Vyper follows C99 scoping rules. Variables are visible from the point "
"right after their declaration until the end of the smallest block that "
"contains the declaration."
msgstr ""

#: ../../scoping-and-declarations.rst:126
msgid "Module Scope"
msgstr ""

#: ../../scoping-and-declarations.rst:128
msgid ""
"Variables and other items declared outside of a code block (functions, "
"constants, event and struct definitions, ...), are visible even before "
"they were declared. This means you can use module-scoped items before "
"they are declared."
msgstr ""

#: ../../scoping-and-declarations.rst:131
msgid "Accessing Module Scope from Functions"
msgstr ""

#: ../../scoping-and-declarations.rst:133
msgid ""
"Values that are declared in the module scope of a contract, such as "
"storage variables and functions, are accessed via the ``self`` object:"
msgstr ""

#: ../../scoping-and-declarations.rst:149
msgid "Name Shadowing"
msgstr ""

#: ../../scoping-and-declarations.rst:151
msgid ""
"It is not permitted for a memory or calldata variable to shadow the name "
"of an immutable or constant value. The following examples will not "
"compile:"
msgstr ""

#: ../../scoping-and-declarations.rst:176
msgid "Function Scope"
msgstr ""

#: ../../scoping-and-declarations.rst:178
msgid ""
"Variables that are declared within a function, or given as function input"
" arguments, are visible within the body of that function. For example, "
"the following contract is valid because each declaration of ``a`` only "
"exists within one function's body."
msgstr ""

#: ../../scoping-and-declarations.rst:194
msgid "The following examples will not compile:"
msgstr ""

#: ../../scoping-and-declarations.rst:217
msgid "Block Scopes"
msgstr ""

#: ../../scoping-and-declarations.rst:219
msgid ""
"Logical blocks created by ``for`` and ``if`` statements have their own "
"scope. For example, the following contract is valid because ``x`` only "
"exists within the block scopes for each branch of the ``if`` statement:"
msgstr ""

#: ../../scoping-and-declarations.rst:230
msgid ""
"In a ``for`` statement, the target variable exists within the scope of "
"the loop. For example, the following contract is valid because ``i`` is "
"no longer available upon exiting the loop:"
msgstr ""

#: ../../scoping-and-declarations.rst:240
msgid ""
"The following contract fails to compile because ``a`` has not been "
"declared outside of the loop."
msgstr ""

