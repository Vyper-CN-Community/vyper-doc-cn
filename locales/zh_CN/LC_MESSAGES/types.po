# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2017-2024 CC-BY-4.0 Vyper Team
# This file is distributed under the same license as the Vyper package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Vyper \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-08 10:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../types.rst:6
msgid "Types"
msgstr ""

#: ../../types.rst:8
msgid ""
"Vyper is a statically typed language. The type of each variable (state "
"and local) must be specified or at least known at compile-time. Vyper "
"provides several elementary types which can be combined to form complex "
"types."
msgstr ""

#: ../../types.rst:10
msgid ""
"In addition, types can interact with each other in expressions containing"
" operators."
msgstr ""

#: ../../types.rst:15
msgid "Value Types"
msgstr ""

#: ../../types.rst:17
msgid ""
"The following types are also called value types because variables of "
"these types will always be passed by value, i.e. they are always copied "
"when they are used as function arguments or in assignments."
msgstr ""

#: ../../types.rst:24
msgid "Boolean"
msgstr ""

#: ../../types.rst:26
msgid "**Keyword:** ``bool``"
msgstr ""

#: ../../types.rst:28
msgid "A boolean is a type to store a logical/truth value."
msgstr ""

#: ../../types.rst:31 ../../types.rst:61 ../../types.rst:147
#: ../../types.rst:237 ../../types.rst:292
msgid "Values"
msgstr ""

#: ../../types.rst:33
msgid "The only possible values are the constants ``True`` and ``False``."
msgstr ""

#: ../../types.rst:36 ../../types.rst:68 ../../types.rst:157
#: ../../types.rst:246 ../../types.rst:338 ../../types.rst:405
msgid "Operators"
msgstr ""

#: ../../types.rst:39 ../../types.rst:76 ../../types.rst:92 ../../types.rst:109
#: ../../types.rst:122 ../../types.rst:165 ../../types.rst:181
#: ../../types.rst:197 ../../types.rst:214 ../../types.rst:254
#: ../../types.rst:270 ../../types.rst:413 ../../types.rst:425
msgid "Operator"
msgstr ""

#: ../../types.rst:39 ../../types.rst:76 ../../types.rst:92 ../../types.rst:109
#: ../../types.rst:122 ../../types.rst:165 ../../types.rst:181
#: ../../types.rst:197 ../../types.rst:214 ../../types.rst:254
#: ../../types.rst:270 ../../types.rst:302 ../../types.rst:341
#: ../../types.rst:413 ../../types.rst:425
msgid "Description"
msgstr ""

#: ../../types.rst:41
msgid "``not x``"
msgstr ""

#: ../../types.rst:41
msgid "Logical negation"
msgstr ""

#: ../../types.rst:42
msgid "``x and y``"
msgstr ""

#: ../../types.rst:42
msgid "Logical conjunction"
msgstr ""

#: ../../types.rst:43
msgid "``x or y``"
msgstr ""

#: ../../types.rst:43
msgid "Logical disjunction"
msgstr ""

#: ../../types.rst:44 ../../types.rst:80 ../../types.rst:169
#: ../../types.rst:258 ../../types.rst:415
msgid "``x == y``"
msgstr ""

#: ../../types.rst:44
msgid "Equality"
msgstr ""

#: ../../types.rst:45 ../../types.rst:81 ../../types.rst:170
#: ../../types.rst:259 ../../types.rst:416
msgid "``x != y``"
msgstr ""

#: ../../types.rst:45
msgid "Inequality"
msgstr ""

#: ../../types.rst:48
msgid ""
"Short-circuiting of boolean operators (``or`` and ``and``) is consistent "
"with the behavior of Python."
msgstr ""

#: ../../types.rst:54
msgid "Signed Integer (N bit)"
msgstr ""

#: ../../types.rst:56
msgid "**Keyword:** ``intN`` (e.g., ``int128``)"
msgstr ""

#: ../../types.rst:58
msgid ""
"A signed integer which can store positive and negative integers. ``N`` "
"must be a multiple of 8 between 8 and 256 (inclusive)."
msgstr ""

#: ../../types.rst:63
msgid ""
"Signed integer values between -2\\ :sup:`N-1` and (2\\ :sup:`N-1` - 1), "
"inclusive."
msgstr ""

#: ../../types.rst:65 ../../types.rst:151
msgid ""
"Integer literals cannot have a decimal point even if the decimal value is"
" zero. For example, ``2.0`` cannot be interpreted as an integer."
msgstr ""

#: ../../types.rst:71 ../../types.rst:160 ../../types.rst:249
#: ../../types.rst:408
msgid "Comparisons"
msgstr ""

#: ../../types.rst:73 ../../types.rst:162 ../../types.rst:251
#: ../../types.rst:410
msgid "Comparisons return a boolean value."
msgstr ""

#: ../../types.rst:78 ../../types.rst:167 ../../types.rst:256
msgid "``x < y``"
msgstr ""

#: ../../types.rst:78 ../../types.rst:167 ../../types.rst:256
msgid "Less than"
msgstr ""

#: ../../types.rst:79 ../../types.rst:168 ../../types.rst:257
msgid "``x <= y``"
msgstr ""

#: ../../types.rst:79 ../../types.rst:168
msgid "Less than or equal to"
msgstr ""

#: ../../types.rst:80 ../../types.rst:169 ../../types.rst:258
#: ../../types.rst:415
msgid "Equals"
msgstr ""

#: ../../types.rst:81 ../../types.rst:170 ../../types.rst:259
#: ../../types.rst:416
msgid "Does not equal"
msgstr ""

#: ../../types.rst:82 ../../types.rst:171 ../../types.rst:260
msgid "``x >= y``"
msgstr ""

#: ../../types.rst:82 ../../types.rst:171
msgid "Greater than or equal to"
msgstr ""

#: ../../types.rst:83 ../../types.rst:172 ../../types.rst:261
msgid "``x > y``"
msgstr ""

#: ../../types.rst:83 ../../types.rst:172 ../../types.rst:261
msgid "Greater than"
msgstr ""

#: ../../types.rst:86 ../../types.rst:103
msgid "``x`` and ``y`` must both be of the same type."
msgstr ""

#: ../../types.rst:89 ../../types.rst:178 ../../types.rst:267
msgid "Arithmetic Operators"
msgstr ""

#: ../../types.rst:94 ../../types.rst:183 ../../types.rst:272
msgid "``x + y``"
msgstr ""

#: ../../types.rst:94 ../../types.rst:183 ../../types.rst:272
msgid "Addition"
msgstr ""

#: ../../types.rst:95 ../../types.rst:184 ../../types.rst:273
msgid "``x - y``"
msgstr ""

#: ../../types.rst:95 ../../types.rst:184 ../../types.rst:273
msgid "Subtraction"
msgstr ""

#: ../../types.rst:96 ../../types.rst:274
msgid "``-x``"
msgstr ""

#: ../../types.rst:96 ../../types.rst:274
msgid "Unary minus/Negation"
msgstr ""

#: ../../types.rst:97 ../../types.rst:185 ../../types.rst:275
msgid "``x * y``"
msgstr ""

#: ../../types.rst:97 ../../types.rst:185 ../../types.rst:275
msgid "Multiplication"
msgstr ""

#: ../../types.rst:98 ../../types.rst:186
msgid "``x // y``"
msgstr ""

#: ../../types.rst:98 ../../types.rst:186
msgid "Integer division"
msgstr ""

#: ../../types.rst:99 ../../types.rst:187
msgid "``x**y``"
msgstr ""

#: ../../types.rst:99 ../../types.rst:187
msgid "Exponentiation"
msgstr ""

#: ../../types.rst:100 ../../types.rst:188 ../../types.rst:277
msgid "``x % y``"
msgstr ""

#: ../../types.rst:100 ../../types.rst:188 ../../types.rst:277
msgid "Modulo"
msgstr ""

#: ../../types.rst:106 ../../types.rst:194 ../../types.rst:422
msgid "Bitwise Operators"
msgstr ""

#: ../../types.rst:111 ../../types.rst:199 ../../types.rst:427
msgid "``x & y``"
msgstr ""

#: ../../types.rst:111 ../../types.rst:199 ../../types.rst:427
msgid "Bitwise and"
msgstr ""

#: ../../types.rst:112 ../../types.rst:200 ../../types.rst:428
msgid "``x | y``"
msgstr ""

#: ../../types.rst:112 ../../types.rst:200 ../../types.rst:428
msgid "Bitwise or"
msgstr ""

#: ../../types.rst:113 ../../types.rst:201 ../../types.rst:429
msgid "``x ^ y``"
msgstr ""

#: ../../types.rst:113 ../../types.rst:201 ../../types.rst:429
msgid "Bitwise xor"
msgstr ""

#: ../../types.rst:116 ../../types.rst:175 ../../types.rst:191
#: ../../types.rst:205
msgid "``x`` and ``y`` must be of the same type."
msgstr ""

#: ../../types.rst:119 ../../types.rst:211
msgid "Shifts"
msgstr ""

#: ../../types.rst:124 ../../types.rst:216
msgid "``x << y``"
msgstr ""

#: ../../types.rst:124 ../../types.rst:216
msgid "Left shift"
msgstr ""

#: ../../types.rst:125 ../../types.rst:217
msgid "``x >> y``"
msgstr ""

#: ../../types.rst:125 ../../types.rst:217
msgid "Right shift"
msgstr ""

#: ../../types.rst:128
msgid ""
"Shifting is only available for 256-bit wide types. That is, ``x`` must be"
" ``int256``, and ``y`` can be any unsigned integer. The right shift for "
"``int256`` compiles to a signed right shift (EVM ``SAR`` instruction)."
msgstr ""

#: ../../types.rst:132 ../../types.rst:224
msgid ""
"While at runtime shifts are unchecked (that is, they can be for any "
"number of bits), to prevent common mistakes, the compiler is stricter at "
"compile-time and will prevent out of bounds shifts. For instance, at "
"runtime, ``1 << 257`` will evaluate to ``0``, while that expression at "
"compile-time will raise an ``OverflowException``."
msgstr ""

#: ../../types.rst:135
msgid ""
"Integer division has different rounding semantics than Python for "
"negative numbers: Vyper rounds towards zero, while Python rounds towards "
"negative infinity. For example, ``-1 // 2`` will return ``-1`` in Python,"
" but ``0`` in Vyper. This preserves the spirit (but not the text!) of the"
" reasoning for Python's round-towards-negative-infinity behavior, which "
"is that the behavior of ``//`` combined with the behavior of ``%`` "
"preserves the following identity no matter if the quantities are negative"
" or non-negative: ``(x // y) * y + (x % y) == x``."
msgstr ""

#: ../../types.rst:140
msgid "Unsigned Integer (N bit)"
msgstr ""

#: ../../types.rst:142
msgid "**Keyword:** ``uintN`` (e.g., ``uint8``)"
msgstr ""

#: ../../types.rst:144
msgid ""
"A unsigned integer which can store positive integers. ``N`` must be a "
"multiple of 8 between 8 and 256 (inclusive)."
msgstr ""

#: ../../types.rst:149
msgid "Integer values between 0 and (2\\ :sup:`N`-1)."
msgstr ""

#: ../../types.rst:154
msgid ""
"Integer literals are interpreted as ``int256`` by default. In cases where"
" ``uint8`` is more appropriate, such as assignment, the literal might be "
"interpreted as ``uint8``. Example: ``_variable: uint8 = _literal``. In "
"order to explicitly cast a literal to a ``uint8`` use ``convert(_literal,"
" uint8)``."
msgstr ""

#: ../../types.rst:202 ../../types.rst:430
msgid "``~x``"
msgstr ""

#: ../../types.rst:202 ../../types.rst:430
msgid "Bitwise not"
msgstr ""

#: ../../types.rst:208
msgid ""
"The Bitwise ``not`` operator is currently only available for ``uint256`` "
"type."
msgstr ""

#: ../../types.rst:220
msgid ""
"Shifting is only available for 256-bit wide types. That is, ``x`` must be"
" ``uint256``, and ``y`` can be any unsigned integer. The right shift for "
"``uint256`` compiles to a signed right shift (EVM ``SHR`` instruction)."
msgstr ""

#: ../../types.rst:229
msgid "Decimals"
msgstr ""

#: ../../types.rst:231
msgid "**Keyword:** ``decimal``"
msgstr ""

#: ../../types.rst:233
msgid ""
"A decimal is a type to store a decimal fixed point value. As of v0.4.0, "
"decimals must be enabled with the CLI flag ``--enable-decimals``."
msgstr ""

#: ../../types.rst:239
msgid ""
"A value with a precision of 10 decimal places between "
"-18707220957835557353007165858768422651595.9365500928 (-2\\ :sup:`167` / "
"10\\ :sup:`10`) and 18707220957835557353007165858768422651595.9365500927 "
"((2\\ :sup:`167` - 1) / 10\\ :sup:`10`)."
msgstr ""

#: ../../types.rst:241
msgid ""
"In order for a literal to be interpreted as ``decimal`` it must include a"
" decimal point."
msgstr ""

#: ../../types.rst:243
msgid ""
"The ABI type (for computing method identifiers) of ``decimal`` is "
"``int168``."
msgstr ""

#: ../../types.rst:257
msgid "Less or equal"
msgstr ""

#: ../../types.rst:260
msgid "Greater or equal"
msgstr ""

#: ../../types.rst:264 ../../types.rst:280
msgid "``x`` and ``y`` must be of the type ``decimal``."
msgstr ""

#: ../../types.rst:276
msgid "``x / y``"
msgstr ""

#: ../../types.rst:276
msgid "Decimal division"
msgstr ""

#: ../../types.rst:285
msgid "Address"
msgstr ""

#: ../../types.rst:287
msgid "**Keyword:** ``address``"
msgstr ""

#: ../../types.rst:289
msgid "The address type holds an Ethereum address."
msgstr ""

#: ../../types.rst:294
msgid ""
"An address type can hold an Ethereum address which equates to 20 bytes or"
" 160 bits. Address literals must be written in hexadecimal notation with "
"a leading ``0x`` and must be `checksummed "
"<https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md>`_."
msgstr ""

#: ../../types.rst:299
msgid "Members"
msgstr ""

#: ../../types.rst:302
msgid "Member"
msgstr ""

#: ../../types.rst:302 ../../types.rst:647
msgid "Type"
msgstr ""

#: ../../types.rst:304
msgid "``balance``"
msgstr ""

#: ../../types.rst:304 ../../types.rst:306 ../../types.rst:656
msgid "``uint256``"
msgstr ""

#: ../../types.rst:304
msgid "Balance of an address"
msgstr ""

#: ../../types.rst:305
msgid "``codehash``"
msgstr ""

#: ../../types.rst:305 ../../types.rst:651
msgid "``bytes32``"
msgstr ""

#: ../../types.rst:305
msgid ""
"Keccak of code at an address, "
"``0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`` if"
" no contract is deployed (see `EIP-1052 "
"<https://eips.ethereum.org/EIPS/eip-1052>`_)"
msgstr ""

#: ../../types.rst:306
msgid "``codesize``"
msgstr ""

#: ../../types.rst:306
msgid "Size of code deployed at an address, in bytes"
msgstr ""

#: ../../types.rst:307
msgid "``is_contract``"
msgstr ""

#: ../../types.rst:307 ../../types.rst:650
msgid "``bool``"
msgstr ""

#: ../../types.rst:307
msgid "Boolean indicating if a contract is deployed at an address"
msgstr ""

#: ../../types.rst:308
msgid "``code``"
msgstr ""

#: ../../types.rst:308
msgid "``Bytes``"
msgstr ""

#: ../../types.rst:308
msgid "Contract bytecode"
msgstr ""

#: ../../types.rst:311
msgid ""
"Syntax as follows: ``_address.<member>``, where ``_address`` is of the "
"type ``address`` and ``<member>`` is one of the above keywords."
msgstr ""

#: ../../types.rst:315
msgid ""
"Operations such as ``SELFDESTRUCT`` and ``CREATE2`` allow for the removal"
" and replacement of bytecode at an address. You should never assume that "
"values of address members will not change in the future."
msgstr ""

#: ../../types.rst:319
msgid ""
"``_address.code`` requires the usage of :func:`slice <slice>` to "
"explicitly extract a section of contract bytecode. If the extracted "
"section exceeds the bounds of bytecode, this will throw. You can check "
"the size of ``_address.code`` using ``_address.codesize``."
msgstr ""

#: ../../types.rst:322
msgid "M-byte-wide Fixed Size Byte Array"
msgstr ""

#: ../../types.rst:324
msgid ""
"**Keyword:** ``bytesM`` This is an M-byte-wide byte array that is "
"otherwise similar to dynamically sized byte arrays. On an ABI level, it "
"is annotated as bytesM (e.g., bytes32)."
msgstr ""

#: ../../types.rst:327
msgid "**Example:** ::"
msgstr ""

#: ../../types.rst:341
msgid "Keyword"
msgstr ""

#: ../../types.rst:343
msgid "``keccak256(x)``"
msgstr ""

#: ../../types.rst:343
msgid "Return the keccak256 hash as bytes32."
msgstr ""

#: ../../types.rst:344
msgid "``concat(x, ...)``"
msgstr ""

#: ../../types.rst:344
msgid "Concatenate multiple inputs."
msgstr ""

#: ../../types.rst:345
msgid "``slice(x, start=_start, len=_len)``"
msgstr ""

#: ../../types.rst:345
msgid "Return a slice of ``_len`` starting at ``_start``."
msgstr ""

#: ../../types.rst:348
msgid ""
"Where ``x`` is a byte array and ``_start`` as well as ``_len`` are "
"integer values."
msgstr ""

#: ../../types.rst:353
msgid "Byte Arrays"
msgstr ""

#: ../../types.rst:355
msgid "**Keyword:** ``Bytes``"
msgstr ""

#: ../../types.rst:357
msgid "A byte array with a max size."
msgstr ""

#: ../../types.rst:359
msgid ""
"The syntax being ``Bytes[maxLen]``, where ``maxLen`` is an integer which "
"denotes the maximum number of bytes. On the ABI level the Fixed-size "
"bytes array is annotated as ``bytes``."
msgstr ""

#: ../../types.rst:362
msgid "Bytes literals may be given as bytes strings or as hex strings."
msgstr ""

#: ../../types.rst:372
msgid "Strings"
msgstr ""

#: ../../types.rst:374
msgid "**Keyword:** ``String``"
msgstr ""

#: ../../types.rst:376
msgid ""
"Fixed-size strings can hold strings with equal or fewer characters than "
"the maximum length of the string. On the ABI level the Fixed-size bytes "
"array is annotated as ``string``."
msgstr ""

#: ../../types.rst:384
msgid "Flags"
msgstr ""

#: ../../types.rst:386
msgid "**Keyword:** ``flag``"
msgstr ""

#: ../../types.rst:388
msgid ""
"Flags are custom defined types. A flag must have at least one member, and"
" can hold up to a maximum of 256 members. The members are represented by "
"``uint256`` values in the form of 2\\ :sup:`n` where ``n`` is the index "
"of the member in the range ``0 <= n <= 255``."
msgstr ""

#: ../../types.rst:417
msgid "``x in y``"
msgstr ""

#: ../../types.rst:417
msgid "x is in y"
msgstr ""

#: ../../types.rst:418
msgid "``x not in y``"
msgstr ""

#: ../../types.rst:418
msgid "x is not in y"
msgstr ""

#: ../../types.rst:433
msgid ""
"Flag members can be combined using the above bitwise operators. While "
"flag members have values that are power of two, flag member combinations "
"may not."
msgstr ""

#: ../../types.rst:435
msgid ""
"The ``in`` and ``not in`` operators can be used in conjunction with flag "
"member combinations to check for membership."
msgstr ""

#: ../../types.rst:454
msgid ""
"Note that ``in`` is not the same as strict equality (``==``). ``in`` "
"checks that *any* of the flags on two flag objects are simultaneously "
"set, while ``==`` checks that two flag objects are bit-for-bit equal."
msgstr ""

#: ../../types.rst:456
msgid ""
"The following code uses bitwise operations to add and revoke permissions "
"from a given ``Roles`` object."
msgstr ""

#: ../../types.rst:481
msgid "Reference Types"
msgstr ""

#: ../../types.rst:483
msgid ""
"Reference types are those whose components can be assigned to in-place "
"without copying. For instance, array and struct members can be "
"individually assigned to without overwriting the whole data structure."
msgstr ""

#: ../../types.rst:487
msgid ""
"In terms of the calling convention, reference types are passed by value, "
"not by reference. That means that, a calling function does not need to "
"worry about a callee modifying the data of a passed structure."
msgstr ""

#: ../../types.rst:492
msgid "Fixed-size Lists"
msgstr ""

#: ../../types.rst:494
msgid ""
"Fixed-size lists hold a finite number of elements which belong to a "
"specified type."
msgstr ""

#: ../../types.rst:496
msgid ""
"Lists can be declared with ``_name: _ValueType[_Integer]``, except "
"``Bytes[N]``, ``String[N]`` and flags."
msgstr ""

#: ../../types.rst:510
msgid ""
"Multidimensional lists are also possible. The notation for the "
"declaration is reversed compared to some other languages, but the access "
"notation is not reversed."
msgstr ""

#: ../../types.rst:512
msgid ""
"A two dimensional list can be declared with ``_name: "
"_ValueType[inner_size][outer_size]``. Elements can be accessed with "
"``_name[outer_index][inner_index]``."
msgstr ""

#: ../../types.rst:529
msgid ""
"Defining an array in storage whose size is significantly larger than "
"``2**64`` can result in security vulnerabilities due to risk of overflow."
msgstr ""

#: ../../types.rst:534
msgid "Dynamic Arrays"
msgstr ""

#: ../../types.rst:536
msgid ""
"Dynamic arrays represent bounded arrays whose length can be modified at "
"runtime, up to a bound specified in the type. They can be declared with "
"``_name: DynArray[_Type, _Integer]``, where ``_Type`` can be of value "
"type or reference type (except mappings)."
msgstr ""

#: ../../types.rst:560
msgid ""
"Attempting to access data past the runtime length of an array, ``pop()`` "
"an empty array or ``append()`` to a full array will result in a runtime "
"``REVERT``. Attempting to pass an array in calldata which is larger than "
"the array bound will result in a runtime ``REVERT``."
msgstr ""

#: ../../types.rst:563
msgid ""
"To keep code easy to reason about, modifying an array while using it as "
"an iterator is disallowed by the language. For instance, the following "
"usage is not allowed:"
msgstr ""

#: ../../types.rst:570
msgid ""
"In the ABI, they are represented as ``_Type[]``. For instance, "
"``DynArray[int128, 3]`` gets represented as ``int128[]``, and "
"``DynArray[DynArray[int128, 3], 3]`` gets represented as ``int128[][]``."
msgstr ""

#: ../../types.rst:573
msgid ""
"Defining a dynamic array in storage whose size is significantly larger "
"than ``2**64`` can result in security vulnerabilities due to risk of "
"overflow."
msgstr ""

#: ../../types.rst:579
msgid "Structs"
msgstr ""

#: ../../types.rst:581
msgid "Structs are custom defined types that can group several variables."
msgstr ""

#: ../../types.rst:583
msgid ""
"Struct types can be used inside mappings and arrays. Structs can contain "
"arrays and other structs, but not mappings."
msgstr ""

#: ../../types.rst:585
msgid "Struct members can be accessed via ``struct.argname``."
msgstr ""

#: ../../types.rst:603
msgid "Mappings"
msgstr ""

#: ../../types.rst:605
msgid ""
"Mappings are `hash tables <https://en.wikipedia.org/wiki/Hash_table>`_ "
"that are virtually initialized such that every possible key exists and is"
" mapped to a value whose byte-representation is all zeros: a type's "
":ref:`default value <types-initial>`."
msgstr ""

#: ../../types.rst:607
msgid ""
"The key data is not stored in a mapping. Instead, its ``keccak256`` hash "
"is used to look up a value. For this reason, mappings do not have a "
"length or a concept of a key or value being \"set\"."
msgstr ""

#: ../../types.rst:609
msgid "Mapping types are declared as ``HashMap[_KeyType, _ValueType]``."
msgstr ""

#: ../../types.rst:611
msgid ""
"``_KeyType`` can be any base or bytes type. Mappings, arrays or structs "
"are not supported as key types."
msgstr ""

#: ../../types.rst:612
msgid "``_ValueType`` can actually be any type, including mappings."
msgstr ""

#: ../../types.rst:615
msgid "Mappings are only allowed as state variables."
msgstr ""

#: ../../types.rst:627
msgid "Mappings have no concept of length and so cannot be iterated over."
msgstr ""

#: ../../types.rst:634
msgid "Initial Values"
msgstr ""

#: ../../types.rst:636
msgid ""
"Unlike most programming languages, Vyper does not have a concept of "
"``null``. Instead, every variable type has a default value. To check if a"
" variable is empty, you must compare it to the default value for its "
"given type."
msgstr ""

#: ../../types.rst:638
msgid ""
"To reset a variable to its default value, assign to it the built-in "
"``empty()`` function which constructs a zero value for that type."
msgstr ""

#: ../../types.rst:642
msgid "Memory variables must be assigned a value at the time they are declared."
msgstr ""

#: ../../types.rst:644
msgid "Here you can find a list of all types and default values:"
msgstr ""

#: ../../types.rst:647
msgid "Default Value"
msgstr ""

#: ../../types.rst:649
msgid "``address``"
msgstr ""

#: ../../types.rst:649
msgid "``0x0000000000000000000000000000000000000000``"
msgstr ""

#: ../../types.rst:650
msgid "``False``"
msgstr ""

#: ../../types.rst:651
msgid "``0x0000000000000000000000000000000000000000000000000000000000000000``"
msgstr ""

#: ../../types.rst:652
msgid "``decimal``"
msgstr ""

#: ../../types.rst:652
msgid "``0.0``"
msgstr ""

#: ../../types.rst:653
msgid "``uint8``"
msgstr ""

#: ../../types.rst:653 ../../types.rst:654 ../../types.rst:655
#: ../../types.rst:656
msgid "``0``"
msgstr ""

#: ../../types.rst:654
msgid "``int128``"
msgstr ""

#: ../../types.rst:655
msgid "``int256``"
msgstr ""

#: ../../types.rst:660
msgid "In ``Bytes``, the array starts with the bytes all set to ``'\\x00'``."
msgstr ""

#: ../../types.rst:663
msgid ""
"In reference types, all the type's members are set to their initial "
"values."
msgstr ""

#: ../../types.rst:669
msgid "Type Conversions"
msgstr ""

#: ../../types.rst:671
msgid ""
"All type conversions in Vyper must be made explicitly using the built-in "
"``convert(a: atype, btype)`` function. Type conversions in Vyper are "
"designed to be safe and intuitive. All type conversions will check that "
"the input is in bounds for the output type. The general principles are:"
msgstr ""

#: ../../types.rst:673
msgid ""
"Except for conversions involving decimals and bools, the input is bit-"
"for-bit preserved."
msgstr ""

#: ../../types.rst:674
msgid "Conversions to bool map all nonzero inputs to 1."
msgstr ""

#: ../../types.rst:675
msgid ""
"When converting from decimals to integers, the input is truncated towards"
" zero."
msgstr ""

#: ../../types.rst:676
msgid ""
"``address`` types are treated as ``uint160``, except conversions with "
"signed integers and decimals are not allowed."
msgstr ""

#: ../../types.rst:677
msgid ""
"Converting between right-padded (``bytes``, ``Bytes``, ``String``) and "
"left-padded types, results in a rotation to convert the padding. For "
"instance, converting from ``bytes20`` to ``address`` would result in "
"rotating the input by 12 bytes to the right."
msgstr ""

#: ../../types.rst:678
msgid ""
"Converting between signed and unsigned integers reverts if the input is "
"negative."
msgstr ""

#: ../../types.rst:679
msgid ""
"Narrowing conversions (e.g., ``int256 -> int128``) check that the input "
"is in bounds for the output type."
msgstr ""

#: ../../types.rst:680
msgid ""
"Converting between bytes and int types results in sign-extension if the "
"output type is signed. For instance, converting ``0xff`` (``bytes1``) to "
"``int8`` returns ``-1``."
msgstr ""

#: ../../types.rst:681
msgid ""
"Converting between bytes and int types which have different sizes follows"
" the rule of going through the closest integer type, first. For instance,"
" ``bytes1 -> int16`` is like ``bytes1 -> int8 -> int16`` (signextend, "
"then widen). ``uint8 -> bytes20`` is like ``uint8 -> uint160 -> bytes20``"
" (rotate left 12 bytes)."
msgstr ""

#: ../../types.rst:682
msgid "Flags can be converted to and from ``uint256`` only."
msgstr ""

#: ../../types.rst:684
msgid ""
"A small Python reference implementation is maintained as part of Vyper's "
"test suite, it can be found `here "
"<https://github.com/vyperlang/vyper/blob/c4c6afd07801a0cc0038cdd4007cc43860c54193/tests/parser/functions/test_convert.py#L318>`__."
" The motivation and more detailed discussion of the rules can be found "
"`here <https://github.com/vyperlang/vyper/issues/2507>`__."
msgstr ""

